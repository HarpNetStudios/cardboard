///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Standard shader definitions:
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

lazyshader = [
	defershader $arg1 $arg2 [
		shader @arg1 @arg2 [@@arg3] [@@arg4]
	]
]

lmcoordscale = (divf 1 32767)

shader 0 "null" [
	attribute vec4 vvertex;
	void main(void)
	{
		gl_Position = vvertex;
	}
] [
	void main(void)
	{
		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
	}
]

///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

screentexcoord = [
	result [
		uniform vec4 screentexcoord@arg1;
		#define vtexcoord@arg1 (vvertex.xy * screentexcoord@arg1.xy + screentexcoord@arg1.zw)
	]
]

shader 0 "hud" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 hudmatrix;
	varying vec2 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = hudmatrix * vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec2 texcoord0;
	varying vec4 color;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0);
	}
]

shader 0 "hudnotexture" [
	attribute vec4 vvertex, vcolor;
	uniform mat4 hudmatrix;
	varying vec4 color;
	void main(void)
	{
		gl_Position = hudmatrix * vvertex;
		color = vcolor;
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]

shader 0 "hudrgb" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 hudmatrix;
	varying vec2 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = hudmatrix * vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec2 texcoord0;
	varying vec4 color;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor.rgb = color.rgb * texture2D(tex0, texcoord0).rgb;
		gl_FragColor.a   = color.a;
	}
]

///////////////////////////////////////////////////
//
// miscellaneous default shaders
//
///////////////////////////////////////////////////

shader 0 "texture" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 camprojmatrix;
	varying vec2 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec2 texcoord0;
	varying vec4 color;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0);
	}
]

shader 0 "notexture" [
	attribute vec4 vvertex, vcolor;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]

shader 0 "cubemap" [
	attribute vec4 vvertex, vcolor;
	attribute vec3 vtexcoord0;
	varying vec3 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec3 texcoord0;
	varying vec4 color;
	uniform samplerCube tex0;
	void main(void)
	{
		gl_FragColor = color * textureCube(tex0, texcoord0);
	}
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 camprojmatrix;
	varying vec2 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec2 texcoord0;
	varying vec4 color;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0);
	}
]

shader 0 "foggednotexture" [
	//:fog
	attribute vec4 vvertex, vcolor;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]

shader 0 "fogoverlay" [
	attribute vec4 vvertex, vcolor;
	varying vec4 color;
	void main(void)
	{
		gl_Position = vvertex;
		color = vcolor;
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	void main() { gl_Position = camprojmatrix * vvertex; }
] [
	void main() {}
]

shader 0 "bbquery" [
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	uniform vec3 bborigin, bbsize;
	void main() { gl_Position = camprojmatrix * vec4(bborigin + vvertex.xyz*bbsize, vvertex.w); }
] [
	void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
	stype = 0
	if (>= (strstr $arg1 "env") 0) [stype = (+ $stype 2)]
	shader $stype $arg1 [
		//:fog
		//:water
		@(if (>= $numargs 5) [result $arg5])
		attribute vec4 vvertex;
		attribute vec3 vnormal;
		attribute vec2 vtexcoord0, vtexcoord1;
		uniform mat4 camprojmatrix;
		uniform vec2 texgenscroll;
		varying vec2 texcoord0, texcoord1;
		void main(void)
		{
			gl_Position = camprojmatrix * vvertex;
			texcoord0 = vtexcoord0 + texgenscroll;
			texcoord1 = vtexcoord1 * @lmcoordscale;

			@arg2

			//:shadowmap
			//:dynlight
		}
	] [
		@(if (>= $numargs 5) [result $arg5])
		@(if (>= $numargs 6) [result $arg6])
		uniform vec4 colorparams;
		varying vec2 texcoord0, texcoord1;
		uniform sampler2D diffusemap, lightmap;
		void main(void)
		{
			@(? (>= (strstr $arg1 "alpha") 0) [
				vec4 diffuse = texture2D(diffusemap, texcoord0);
				diffuse.rgb *= diffuse.a;
				//:fog fogcolor * diffuse.a
			] [
				vec4 diffuse = vec4(texture2D(diffusemap, texcoord0).rgb, 1.0);
			])
			vec4 lm = texture2D(lightmap, texcoord1);

			//:shadowmap lm
			//:dynlight lm

			@arg3

			diffuse *= colorparams;
			@(if (|| (< $numargs 4) [=s $arg4 []]) [result [gl_FragColor = diffuse * lm;]] [result $arg4])
		}
	]
]

glareworldshader = [
	variantshader (if (< (strstr $arg1 "env") 0) 4 6) $arg1 4 [
		//:fog
		@(if (>= $numargs 4) [result $arg4])
		attribute vec4 vvertex;
		attribute vec3 vnormal;
		attribute vec2 vtexcoord0, vtexcoord1;
		uniform mat4 camprojmatrix;
		uniform vec2 texgenscroll;
		varying vec2 texcoord0, texcoord1;
		void main(void)
		{
			gl_Position = camprojmatrix * vvertex;
			texcoord0 = vtexcoord0 + texgenscroll;
			texcoord1 = vtexcoord1 * @lmcoordscale;

			@arg2
		}
	] [
		@(if (>= $numargs 4) [result $arg4])
		@(if (>= $numargs 5) [result $arg5])
		uniform vec4 colorparams;
		varying vec2 texcoord0, texcoord1;
		void main(void)
		{
			@arg3
		}
	]
]

worldshader "stdworld" [] []
worldshader "alphaworld" [] []

defershader 0 "decalworld" [
  worldshader "decalworld" [] [
	vec4 diffuse2 = texture2D(decal, texcoord0);
	diffuse.rgb = mix(diffuse.rgb, diffuse2.rgb, diffuse2.a);
  ] [] [] [uniform sampler2D decal;]
]

glowshader = [
  defershader 0 $arg1 [
	defuniformparam "glowcolor" 1 1 1 // glow color
	worldshader @arg1 [] [] [
	  vec3 glow = texture2D(glowmap, texcoord0).rgb;
	  glow *= glowcolor.rgb;
	  gl_FragColor = diffuse*lm + vec4(glow, 0.0);
	] [] [uniform sampler2D glowmap;]
	glareworldshader @arg1 [] [
	  vec3 glow = texture2D(glowmap, texcoord0).rgb;
	  glow *= glowcolor.rgb;
	  float k = max(glow.r, max(glow.g, glow.b));
	  gl_FragColor.rgb = min(k*k*32.0, 1.0) * glow;
	  gl_FragColor.a =
		  //:variantoverride texture2D(lightmap, texcoord1).a
		  colorparams.a
		  ;
	] [] [
	  uniform sampler2D glowmap;
	  //:variant uniform sampler2D lightmap;
	]
  ]
]
glowshader "glowworld"
glowshader "glowalphaworld"

defershader 0 "pulseworld" [
  defuniformparam "pulsespeed" 1 // pulse frequency (Hz)
  worldshader "pulseworld" [
	pulse = abs(fract(millis * pulsespeed.x)*2.0 - 1.0);
  ] [
	vec3 diffuse2 = texture2D(decal, texcoord0).rgb;
	diffuse.rgb = mix(diffuse.rgb, diffuse2, pulse);
  ] [] [uniform float millis; varying float pulse;] [uniform sampler2D decal;]
]

pulseglowshader = [
  defershader 0 $arg1 [
	defuniformparam "glowcolor" 1 1 1 // glow color
	defuniformparam "pulseglowspeed" 1 // pulse frequency (Hz)
	defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
	worldshader @arg1 [
	  pulse = mix(glowcolor.rgb, pulseglowcolor.rgb, abs(fract(millis * pulseglowspeed.x)*2.0 - 1.0));
	] [] [
	  vec3 glow = texture2D(glowmap, texcoord0).rgb;
	  gl_FragColor = diffuse*lm + vec4(glow*pulse, 0.0);
	] [uniform float millis; varying vec3 pulse;] [uniform sampler2D glowmap;]
	glareworldshader @arg1 [
	  pulse = mix(glowcolor.rgb, pulseglowcolor.rgb, abs(fract(millis * pulseglowspeed.x)*2.0 - 1.0));
	] [
	  vec3 glow = texture2D(glowmap, texcoord0).rgb;
	  glow *= pulse;
	  float k = max(glow.r, max(glow.g, glow.b));
	  gl_FragColor.rgb = min(k*k*32.0, 1.0) * glow;
	  gl_FragColor.a =
		  //:variantoverride texture2D(lightmap, texcoord1).a
		  colorparams.a
		  ;
	] [uniform float millis; varying vec3 pulse;] [
	  uniform sampler2D glowmap;
	  //:variant uniform sampler2D lightmap;
	]
  ]
]
pulseglowshader "pulseglowworld"
pulseglowshader "pulseglowalphaworld"

shader 0 "fogworld" [
	//:water
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
	}
] [
	uniform vec3 fogcolor;
	void main(void)
	{
		gl_FragColor = vec4(fogcolor, 1.0);
	}
]

shader 0 "noglareworld" [
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
	}
] [
	void main(void)
	{
		gl_FragColor = vec4(0.0);
	}
]

shader 0 "noglareblendworld" [
	attribute vec4 vvertex;
	attribute vec2 vtexcoord1;
	uniform mat4 camprojmatrix;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		texcoord0 = vtexcoord1 * @lmcoordscale;
	}
] [
	varying vec2 texcoord0;
	uniform sampler2D lightmap;
	void main(void)
	{
		gl_FragColor.rgb = vec3(0.0);
		gl_FragColor.a = texture2D(lightmap, texcoord0).a;
	}
]

shader 0 "noglarealphaworld" [
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
	}
] [
	uniform vec4 colorparams;
	uniform sampler2D lightmap;
	void main(void)
	{
		gl_FragColor.rgb = vec3(0.0);
		gl_FragColor.a = colorparams.a;
	}
]

defershader 2 "envworld" [
  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity
  worldshader "envworld" [
	normal = vnormal;
	camvec = camera - vvertex.xyz;
  ] [
	vec3 reflect = textureCube(envmap, 2.0*normal*dot(camvec, normal) - camvec).rgb;
  ] [
	diffuse *= lm;
	gl_FragColor.rgb = mix(diffuse.rgb, reflect, envscale.rgb);
	gl_FragColor.a = diffuse.a;
  ] [uniform vec3 camera; varying vec3 normal, camvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity
  worldshader "envworldfast" [
	vec3 camvec = camera - vvertex.xyz;
	rvec = 2.0*vnormal*dot(camvec, vnormal) - camvec;
  ] [
	vec3 reflect = textureCube(envmap, rvec).rgb;
  ] [
	diffuse *= lm;
	gl_FragColor.rgb = mix(diffuse.rgb, reflect, envscale.rgb);
	gl_FragColor.a = diffuse.a;
  ] [uniform vec3 camera; varying vec3 rvec;] [uniform samplerCube envmap;]

  defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity
  worldshader "envworldalt" [] []

  altshader envworld envworldalt
  fastshader envworld envworldfast 2
  fastshader envworld envworldalt 1
]

shader 0 "depthfxworld" [
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	uniform vec4 depthscale, depthoffsets;
	varying vec4 depthranges;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		depthranges = depthoffsets + gl_Position.w*depthscale;
	}
] [
	varying vec4 depthranges;
	void main(void)
	{
		gl_FragColor = depthranges;
	}
]

shader 0 depthfxsplitworld [
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	uniform vec4 depthscale, depthoffsets;
	varying vec4 depthranges;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		depthranges = depthoffsets + gl_Position.w*depthscale;
	}
] [
	varying vec4 depthranges;
	void main(void)
	{
		vec4 ranges = vec4(depthranges.x, fract(depthranges.yzw));
		ranges.xy -= ranges.yz*vec2(0.00390625, 0.00390625);
		gl_FragColor = ranges;
	}
]

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (7 steps)
//    g -> glow
//    G -> pulse glow
//    i -> glare intensity
//    a -> alpha map

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
	bumptype = $arg2
	stype = (? (btopt "e") 3 1)
	if (! (btopt "i")) [
		if (btopt "G") [
			defuniformparam "glowcolor" 1 1 1 // glow color
			defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
			defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
		] [if (btopt "g") [
			defuniformparam "glowcolor" 1 1 1  // glow color
		]]
		if (btopt "S") [
			defuniformparam "specscale" 6 6 6 // spec map multiplier
		] [if (btopt "s") [
			defuniformparam "specscale" 1 1 1 // spec multiplier
		]]
		if (|| (btopt "p") (btopt "P")) [
			defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
		]
		if (btopt "R") [
			defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
		] [if (btopt "r") [
			defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity
		]]
	] [
		if (btopt "s") [stype = (+ $stype 8)]
	]
	variantshader $stype $arg1 (? (btopt "i") 4 -1) [
		//:fog
		attribute vec4 vvertex;
		attribute vec3 vnormal;
		attribute vec2 vtexcoord0, vtexcoord1;
		@(? (btopt "o") [attribute vec4 vtangent;])
		uniform mat4 camprojmatrix;
		uniform vec2 texgenscroll;
		varying vec2 texcoord0, texcoord1;
		@(if (|| (btopt "t") (btopt "r")) [result [uniform vec3 camera; varying vec3 camvec;]])
		@(if (btopt "G") [result [uniform float millis; varying float pulse;]])
		@(if (btopt "r") [result [varying mat3 world;]])
		void main(void)
		{
			gl_Position = camprojmatrix * vvertex;
			texcoord0 = vtexcoord0 + texgenscroll;
			texcoord1 = vtexcoord1 * @lmcoordscale;

			@(if (btopt "o") [result [
				vec3 bitangent = cross(vnormal, vtangent.xyz) * vtangent.w;
				@@(if (btopt "t") [result [
					// trans eye vector into TS
					vec3 camobj = camera - vvertex.xyz;
					camvec = vec3(dot(camobj, vtangent.xyz), dot(camobj, bitangent), dot(camobj, vnormal));
				]])
				@@(if (btopt "r") [result [
					@@(if (! (btopt "t")) [result [
						camvec = camera - vvertex.xyz;
					]])
					// calculate tangent -> world transform
					world = mat3(vtangent.xyz, bitangent, vnormal);
				]])
			]])

			@(if (btopt "G") [result [
				pulse = abs(fract(millis*pulseglowspeed.x)*2.0 - 1.0);
			]])

			@(if (|| (! (btopt "i")) (btopt "s")) [result [
				//:dynlight
			]])
			@(if (! (btopt "i")) [result [
				//:shadowmap
				//:water
			]])
		}
	] [
		uniform vec4 colorparams;
		varying vec2 texcoord0, texcoord1;
		uniform sampler2D diffusemap, lmcolor, lmdir;
		@(if (|| (! (btopt "i")) (btopt "s") (btopt "p") (btopt "P")) [result [uniform sampler2D normalmap;]])
		@(if (|| (btopt "t") (btopt "r")) [result [varying vec3 camvec;]])
		@(if (btopt "g") [result [uniform sampler2D glowmap;]])
		@(if (btopt "G") [result [varying float pulse;]])
		@(if (btopt "r") [result [uniform samplerCube envmap; varying mat3 world;]])
		@(if (|| (! (btopt "i")) (btopt "s")) [result [uniform vec4 ambient;]])
		void main(void)
		{
			@(if (|| (! (btopt "i")) (btopt "s")) [result [
				vec4 lmc = texture2D(lmcolor, texcoord1);
				gl_FragColor.a = colorparams.a * lmc.a;
				vec3 lmlv = texture2D(lmdir, texcoord1).rgb*2.0 - 1.0;
			]])
			@(if (btopt "t") [result [vec3 camdir = normalize(camvec);]])
			@(if (btopt "p") [result [
				float height = texture2D(normalmap, texcoord0).a;
				vec2 dtc = texcoord0 + camdir.xy*(height*parallaxscale.x + parallaxscale.y);
			]])
			@(if (btopt "P") [result [
				const float step = -1.0/7.0;
				vec3 duv = vec3((step*parallaxscale.x/camdir.z)*camdir.xy, step);
				vec3 htc = vec3(texcoord0 + duv.xy*parallaxscale.y, 1.0);
				vec4 height = texture2D(normalmap, htc.xy);
				@@(loopconcat i 7 [concatword [
					htc += height.w < htc.z ? duv : vec3(0.0);
					height = texture2D(normalmap, htc.xy);
				]])
				#define dtc htc.xy
				#define bump height.xyz
			]])
			@(if (|| (btopt "p") (btopt "P")) [] [result [#define dtc texcoord0]])

			@(if (|| (! (btopt "i")) (btopt "S") (btopt "a")) [result [
				vec4 diffuse = texture2D(diffusemap, dtc);
				@(if (&& (btopt "a") (! (btopt "S"))) [result [
					#define alpha diffuse.a
				]])
			]])
			@(if (! (btopt "i")) [result [
				diffuse.rgb *= colorparams.rgb;
			]])
			@(if (|| (! (btopt "i")) (btopt "s") (btopt "a")) [result [
				@(if (! (btopt "P")) [
					if (&& (btopt "a") (btopt "S")) [result [
						vec4 normal = texture2D(normalmap, dtc);
						#define alpha normal.a
						#define bump normal.rgb
					]] [result [
						vec3 bump = texture2D(normalmap, dtc).rgb;
					]]
				])
				bump = bump*2.0 - 1.0;
			]])

			@(if (btopt "s") [result [
				vec3 halfangle = normalize(camdir + lmlv);
				float spec = pow(clamp(dot(halfangle, bump), 0.0, 1.0), @(? (btopt "i") "128.0" "32.0"));
				@(if (btopt "i") [result [spec = min(spec*64.0, 1.0);]])
				@(if (btopt "S") [result [spec *= diffuse.a;]])
				@(if (btopt "i") [result [
					@(? (btopt "S") "diffuse.rgb" "vec3 diffuse") = specscale.xyz*spec;
				]] [result [
					diffuse.rgb += specscale.xyz*spec;
				]])
			]])

			@(if (|| (! (btopt "i")) (btopt "s")) [result [
				lmc.rgb = max(lmc.rgb*clamp(dot(lmlv, bump), 0.0, 1.0), ambient.xyz);
				@(if (btopt "i") [result [
					//:dynlight lmc

					@(? (btopt "g") "diffuse.rgb" "gl_FragColor.rgb") = diffuse.rgb * lmc.rgb;
				]] [result [
					//:shadowmap lmc
					//:dynlight lmc

					@(? (|| (btopt "g") (btopt "r")) "diffuse.rgb" "gl_FragColor.rgb") = diffuse.rgb * lmc.rgb;
				]])
			]])

			@(if (btopt "r") [result [
				vec3 rvec;
				@(if (btopt "t") [result [
					vec3 rvects = 2.0*bump*dot(camvec, bump) - camvec;
					rvec = world * rvects;
				]] [result [
					vec3 bumpw = world * bump;
					rvec = 2.0*bumpw*dot(camvec, bumpw) - camvec;
				]])
				vec3 reflect = textureCube(envmap, rvec).rgb;
				@@(if (btopt "R") [result [
					vec3 rmod = envscale.xyz*diffuse.a;
				]] [result [
					#define rmod envscale.xyz
				]])
				@(? (btopt "g") "diffuse.rgb" "gl_FragColor.rgb") = mix(diffuse.rgb, reflect, rmod);
			]])

			@(if (btopt "a") [result [
				@(? (btopt "g") "diffuse.rgb" "gl_FragColor.rgb") *= alpha;
			]])

			@(if (btopt "g") [result [
				vec3 glow = texture2D(glowmap, dtc).rgb;
				@@(if (btopt "G") [result [
					vec3 pulsecol = mix(glowcolor.xyz, pulseglowcolor.xyz, pulse);
				]])
				@@(if (btopt "i") [result [
					glow *= @(? (btopt "G") "pulsecol" "glowcolor.xyz");
					float k = max(glow.r, max(glow.g, glow.b));
					k = min(k*k*32.0, 1.0);
					@(if (btopt "s") [result [
						gl_FragColor.rgb = glow*k + diffuse.rgb;
					]] [result [
						gl_FragColor.rgb = glow*k;
						gl_FragColor.a =
							//:variantoverride texture2D(lmcolor, texcoord1).a
							colorparams.a
							;
					]])
				]] [result [
					gl_FragColor.rgb = glow * @(? (btopt "G") "pulsecol" "glowcolor.xyz") + diffuse.rgb;
				]])
			]])

			@(if (btopt "a") [result [
				gl_FragColor.a *= alpha;
				//:fog fogcolor * alpha
			]])
		}
	]
]

bumpshader = [
	defershader (? (>= (strstr $arg2 "e") 0) 3 1) $arg1 [
		bumpvariantshader @arg1 @arg2
		if (|| (btopt "g") (btopt "s")) [
			bumpvariantshader @@arg1 (strreplace (concatword @@arg2 "i") "r")
		]
	]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpalphaworld" "a"
bumpshader "bumpspecalphaworld" "otsa"
fastshader bumpspecalphaworld bumpalphaworld 1
altshader bumpspecalphaworld bumpalphaworld
bumpshader "bumpspecmapalphaworld" "otsSa"
fastshader bumpspecmapalphaworld bumpalphaworld 1
altshader bumpspecmapalphaworld bumpalphaworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "otsg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "otsSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "otsgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "otsSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "pot"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "pots"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "potsS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "potsg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "eor"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "eorg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epotr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "epotrg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

////////////////////////////////////////////////
//
// model shaders
//
////////////////////////////////////////////////

// skeletal animation for dual quaternions

qtangentdecode = [
	? $arg1 [
		vec4 qxyz = mquat.xxyy*mquat.yzyz, qxzw = vec4(mquat.xzw, -mquat.w);
		vec3 mtangent = (qxzw.yzw*mquat.zzy + qxyz.zxy)*vec3(-2.0, 2.0, 2.0) + vec3(1.0, 0.0, 0.0);
		vec3 mnormal = (qxzw.zwx*mquat.yxx + qxyz.ywz)*vec3(2.0, 2.0, -2.0) + vec3(0.0, 0.0, 1.0);
		// vec3 mtangent = cross(mquat.xyz, vec3(mquat.wz, -mquat.y))*2.0 + vec3(1.0, 0.0, 0.0);
		// vec3 mnormal = cross(mquat.xyz, vec3(mquat.y, -mquat.x, mquat.w))*2.0 + vec3(0.0, 0.0, 1.0);
	] [
		vec3 mnormal = cross(mquat.xyz, vec3(mquat.y, -mquat.x, mquat.w))*2.0 + vec3(0.0, 0.0, 1.0);
	]
]

skelanimdefs = [
	skelanimlength = (min (- $maxvsuniforms (+ $reservevpparams 10)) $maxskelanimdata)
	result [
		attribute vec4 vboneweight;
		attribute vec4 vboneindex;
		//:uniform animdata
		uniform vec4 animdata[@@skelanimlength];
	]
]

skelanim = [
	result [
		int index = int(vboneindex.x);
		@(if (= $arg1 1) [result [
			vec4 dqreal = animdata[index];
			vec4 dqdual = animdata[index+1];
		]] [result [
			vec4 dqreal = animdata[index] * vboneweight.x;
			vec4 dqdual = animdata[index+1] * vboneweight.x;
			index = int(vboneindex.y);
			dqreal += animdata[index] * vboneweight.y;
			dqdual += animdata[index+1] * vboneweight.y;
			@(if (>= $arg1 3) [result [
				index = int(vboneindex.z);
				dqreal += animdata[index] * vboneweight.z;
				dqdual += animdata[index+1] * vboneweight.z;
			]])
			@(if (>= $arg1 4) [result [
				index = int(vboneindex.w);
				dqreal += animdata[index] * vboneweight.w;
				dqdual += animdata[index+1] * vboneweight.w;
			]])
			float len = length(dqreal);
			dqreal /= len;
			dqdual /= len;
		]])

		vec4 mpos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, vvertex.xyz) + vvertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + vvertex.xyz, vvertex.w);

		@(if $arg2 [result [
			vec4 mquat = vec4(cross(dqreal.xyz, vtangent.xyz) + dqreal.xyz*vtangent.w + vtangent.xyz*dqreal.w, dqreal.w*vtangent.w - dot(dqreal.xyz, vtangent.xyz));
			@(qtangentdecode $arg3)
		]] [if (>= $numargs 2) [result [
			vec3 mnormal = cross(dqreal.xyz, cross(dqreal.xyz, vnormal) + vnormal*dqreal.w)*2.0 + vnormal;
		]]])
	]
]

// model shadowmapping

shadowmapcastervertexshader = [
	result [
		@(if (>= $numargs 2) [result $arg1])
		attribute vec4 vvertex;
		uniform mat4 modelmatrix;
		uniform vec4 shadowintensity;
		varying vec4 shadowmapvals;
		void main(void)
		{
			@(if (>= $numargs 2) [result $arg2] [result [
				#define mpos vvertex
			]])
			gl_Position = modelmatrix * mpos;
			shadowmapvals = vec4(1.0 - gl_Position.z, 1.0, 0.0, shadowintensity.x);
		}
	]
]

shader 0 shadowmapcaster (shadowmapcastervertexshader) [
	varying vec4 shadowmapvals;
	void main(void)
	{
		gl_FragColor = shadowmapvals;
	}
]
loop i 4 [
	variantshader 0 shadowmapcaster 0 (shadowmapcastervertexshader (skelanimdefs (+ $i 1)) (skelanim (+ $i 1))) []
]

shader 0 "shadowmapreceiver" [
	attribute vec4 vvertex;
	uniform mat4 shadowmatrix;
	uniform vec2 shadowmapbias;
	varying vec4 shadowmapvals;
	void main(void)
	{
		gl_Position = shadowmatrix * vvertex;
		shadowmapvals = vec4(0.0, 0.0, shadowmapbias.y - gl_Position.z, 0.0);
	}
] [
	varying vec4 shadowmapvals;
	void main(void)
	{
		gl_FragColor = shadowmapvals;
	}
]

// model stenciling

notexturemodelvertexshader = [
	result [
		attribute vec4 vvertex, vcolor;
		uniform mat4 modelmatrix;
		varying vec4 color;
		@(if (>= $numargs 2) [result $arg1])
		//:fog
		void main(void)
		{
			@(if (>= $numargs 2) [result $arg2] [result [
				#define mpos vvertex
			]])
			gl_Position = modelmatrix * mpos;
			color = vcolor;
		}
	]
]

shader 0 notexturemodel (notexturemodelvertexshader) [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]
loop i 4 [
	variantshader 0 notexturemodel 0 (notexturemodelvertexshader (skelanimdefs (+ $i 1)) (skelanim (+ $i 1))) []
]

// mdltype:
//    e -> envmap
//    n -> normalmap
//    s -> spec
//    m -> masks
//    b -> dual-quat skeletal animation
//    a -> alpha-tested
//    q -> qtangents
//    i -> glare intensity

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

modelvertexshader = [
	modeltype = $arg1
	result [
		@(if (mdlopt "b") [skelanimdefs $arg2 (mdlopt "q") (mdlopt "n")])
		//:fog
		attribute vec4 vvertex, vcolor;
		attribute vec2 vtexcoord0;
		@(if (mdlopt "q") [result [
			attribute vec4 vtangent;
		]] [result [
			attribute vec3 vnormal;
		]])
		uniform mat4 modelmatrix;
		uniform vec3 modelcamera, lightdir, lightscale;
		uniform vec2 texscroll;
		varying vec2 texcoord0;
		varying vec4 color;
		@(if (mdlopt "n") [result [
			@(if (mdlopt "e") [result [
				uniform mat3 modelworld;
				varying vec3 camvec;
				varying mat3 world;
			]] [result [
				varying vec3 lightvec, halfangle;
			]])
		]] [result [
			@(if (mdlopt "s") [result [
				varying vec3 nvec, halfangle;
			]])
			@(if (mdlopt "e") [result [
				uniform mat3 modelworld;
				uniform vec2 envmapscale;
				varying vec3 rvec;
				varying float rmod;
			]])
		]])
		void main(void)
		{
			@(if (mdlopt "b") [result [
				@(skelanim $arg2 (mdlopt "q") (mdlopt "n"))
			]] [result [
				#define mpos vvertex
				@(if (mdlopt "q") [result [
					#define mquat vtangent
					@(qtangentdecode (mdlopt "n"))
				]] [result [
					#define mnormal vnormal
				]])
			]])

			gl_Position = modelmatrix * mpos;

			@(if (|| (mdlopt "n") (mdlopt "s") (mdlopt "i")) [result [
				color = vcolor;
			]])
			texcoord0 = vtexcoord0 + texscroll;

			@(if (|| (mdlopt "e") (mdlopt "s")) [result [
				vec3 camdir = normalize(modelcamera - mpos.xyz);
			]])

			@(if (mdlopt "n") [
				if (mdlopt "e") [result [
					camvec = modelworld * camdir;
					// composition of tangent -> object and object -> world transforms
					//   becomes tangent -> world
					vec3 wnormal = modelworld * mnormal;
					vec3 wtangent = modelworld * mtangent;
					vec3 wbitangent = cross(wnormal, wtangent) * (vtangent.w < 0.0 ? -1.0 : 1.0);
					world = mat3(wtangent, wbitangent, wnormal);
				]] [result [
					vec3 mbitangent = cross(mnormal, mtangent) * (vtangent.w < 0.0 ? -1.0 : 1.0);
					lightvec = vec3(dot(lightdir, mtangent), dot(lightdir, mbitangent), dot(lightdir, mnormal));
					@(if (mdlopt "s") [result [
						vec3 halfdir = lightdir + camdir;
						halfangle = vec3(dot(halfdir, mtangent), dot(halfdir, mbitangent), dot(halfdir, mnormal));
					]])
				]]
			] [result [
				@(if (mdlopt "s") [result [
					nvec = mnormal;
					halfangle = lightdir + camdir;
				]] [if (! (mdlopt "i")) [result [
					float intensity = dot(mnormal, lightdir);
					color = vec4(vcolor.rgb*clamp(intensity*(intensity*lightscale.x + lightscale.y) + lightscale.z, 0.0, 1.0), vcolor.a);
				]]])
				@(if (mdlopt "e") [result [
					float invfresnel = dot(camdir, mnormal);
					rvec = modelworld * (2.0*invfresnel*mnormal - camdir);
					rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;
				]])
			]])
		}
	]
]

modelfragmentshader = [
	modeltype = $arg1
	result [
		varying vec2 texcoord0;
		varying vec4 color;
		@(if (mdlopt "n") [result [
			@(if (mdlopt "e") [result [
				#define lightvec lightdirworld
				uniform vec3 lightdirworld;
				uniform vec2 envmapscale;
				varying vec3 camvec;
				varying mat3 world;
			]] [result [
				varying vec3 lightvec, halfangle;
			]])
		]] [result [
			@(if (mdlopt "s") [result [
				#define lightvec lightdir
				uniform vec3 lightdir;
				varying vec3 nvec, halfangle;
			]])
			@(if (mdlopt "e") [result [
				varying vec3 rvec;
				varying float rmod;
			]])
		]])
		@(if (&& (|| (mdlopt "s") (mdlopt "n")) (! (mdlopt "i"))) [result [uniform vec3 lightscale;]])
		@(if (|| (mdlopt "s") (mdlopt "m")) [result [uniform vec4 maskscale;]])
		uniform sampler2D tex0;
		@(if (mdlopt "m") [result [uniform sampler2D tex1;]])
		@(if (mdlopt "e") [result [uniform samplerCube tex2;]])
		@(if (mdlopt "n") [result [uniform sampler2D tex3;]])
		@(? (mdlopt "a") [uniform float alphatest;])
		void main(void)
		{
			vec4 light = texture2D(tex0, texcoord0);

			@(? (mdlopt "a") [
				if(light.a <= alphatest)
					discard;
			])

			light.rgb *= 2.0;

			@(if (mdlopt "m") [result [
				vec3 masks = texture2D(tex1, texcoord0).rgb;
				vec3 glow = light.rgb * maskscale.y;
			]])

			@(if (mdlopt "n") [result [
				vec3 normal = texture2D(tex3, texcoord0).rgb - 0.5;
				@(if (mdlopt "e") [result [
					normal = world * normal;
				]])
				normal = normalize(normal);
			]])

			@(if (mdlopt "s") [result [
				@(if (mdlopt "n") [
					if (mdlopt "e") [result [
						vec3 halfangle = lightvec + camvec;
					]]
				] [result [
					vec3 normal = normalize(nvec);
				]])
				float spec = maskscale.x * pow(clamp(dot(normalize(halfangle), normal), 0.0, 1.0), @(? (mdlopt "i") "256.0" "128.0"));
				@(if (mdlopt "m") [result [spec *= masks.r;]])   // specmap in red channel
			]])

			@(if (mdlopt "i") [
				if (mdlopt "s") [result [
					spec *= maskscale.z;
					@(? (mdlopt "m") "light.rgb" "gl_FragColor.rgb") = spec * color.rgb;
				]] [
					if (! (mdlopt "m")) [result [gl_FragColor.rgb = vec3(0.0);]]
				]
			] [result [
				@(if (|| (mdlopt "s") (mdlopt "n")) [result [
					float intensity = dot(normal, lightvec);
					light.rgb *= clamp(intensity*(intensity*lightscale.x + lightscale.y) + lightscale.z, 0.0, 1.0);
				]])
				@(if (mdlopt "s") [result [
					light.rgb += spec;
				]])
				@(if (|| (mdlopt "m") (mdlopt "e")) [result [
					light.rgb *= color.rgb;
				]] [result [
					gl_FragColor = light * color;
				]])
			]])

			@(if (mdlopt "e") [result [
				@(if (mdlopt "n") [result [
					vec3 camn = normalize(camvec);
					float invfresnel = dot(camn, normal);
					vec3 rvec = 2.0*invfresnel*normal - camn;
					float rmod = envmapscale.x*max(invfresnel, 0.0) + envmapscale.y;
				]])
				vec3 reflect = textureCube(tex2, rvec).rgb;
				@(if (! (mdlopt "m")) [result [
					gl_FragColor.rgb = mix(light.rgb, reflect, rmod);
				]])
			]])

			@(if (mdlopt "m") [result [
				@(if (mdlopt "e") [result [
					light.rgb = mix(light.rgb, glow, masks.g); // glow mask in green channel
					gl_FragColor.rgb = mix(light.rgb, reflect, rmod*masks.b); // envmap mask in blue channel
				]] [if (mdlopt "i") [result [
					float k = min(masks.g*masks.g*maskscale.w, 1.0); // glow mask in green channel
					gl_FragColor.rgb = @(? (mdlopt "s") "glow*k + light.rgb" "glow*k");
				]] [result [
					gl_FragColor.rgb = mix(light.rgb, glow, masks.g); // glow mask in green channel
				]]])
			]])

			@(if (|| (mdlopt "i") (mdlopt "m") (mdlopt "e")) [result [
				gl_FragColor.a = light.a * color.a;
			]])
		}
	]
]

modelshader = [
	local shadername
	shadername = (concatword model $arg1)
	if (! (isshaderdefined $shadername)) [
		shader 0 $shadername (modelvertexshader $arg1) (modelfragmentshader $arg1)
		loop i 4 [
			variantshader 0 $shadername 0 (modelvertexshader (concatword $arg1 "b") (+ $i 1)) []
		]
		glaremodeltype = (strreplace (concatword $arg1 "i") "e")
		if (< (strstr $glaremodeltype "s") 0) [glaremodeltype = (strreplace $glaremodeltype "n")]
		variantshader 0 $shadername 1 (modelvertexshader $glaremodeltype) (modelfragmentshader $glaremodeltype)
		loop i 4 [
			variantshader 0 $shadername 1 (modelvertexshader (concatword $glaremodeltype "b") (+ $i 1)) 1
		]
		if (>= (strstr $arg1 "e") 0) [
			altshader $shadername (modelshader (strreplace $arg1 "e"))
		]
		if (>= (strstr $arg1 "s") 0) [
			fastshader $shadername (modelshader (strreplace $arg1 "s")) 1
		]
	]
	result $shadername
]

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
	shader 0 $arg1 [
		attribute vec4 vvertex;
		@(screentexcoord 0)
		uniform float offsets[8];
		varying vec2 texcoord0, texcoordp1, texcoordn1;
		@(loopconcat i (min (- $arg2 1) 2) [result [
			varying vec2 texcoordp@(+ $i 2), texcoordn@(+ $i 2);
		]])
		void main(void)
		{
			gl_Position = vvertex;
			texcoord0 = vtexcoord0;
			vec2 tcp = vtexcoord0, tcn = vtexcoord0;
			tcp.@arg3 += offsets[1];
			tcn.@arg3 -= offsets[1];
			texcoordp1 = tcp;
			texcoordn1 = tcn;
			@(loopconcat i (min (- $arg2 1) 2) [result [
				tcp.@arg3 = vtexcoord0.@arg3 + offsets[@@(+ $i 2)];
				tcn.@arg3 = vtexcoord0.@arg3 - offsets[@@(+ $i 2)];
				texcoordp@(+ $i 2) = tcp;
				texcoordn@(+ $i 2) = tcn;
			]])
		}
	] [
		uniform float weights[8];
		uniform float offsets[8];
		varying vec2 texcoord0, texcoordp1, texcoordn1;
		@(loopconcat i (min (- $arg2 1) 2) [result [
			varying vec2 texcoordp@(+ $i 2), texcoordn@(+ $i 2);
		]])
		uniform sampler2D tex0;
		void main(void)
		{
			#define texval(coords) texture2D(tex0, (coords))
			vec4 val = texval(texcoord0) * weights[0];
			@(loopconcat i $arg2 [
				if (< $i 3) [result [
					val += weights[@@(+ $i 1)] * (texval(texcoordp@(+ $i 1)) + texval(texcoordn@(+ $i 1)));
				]] [result [
					val += weights[@@(+ $i 1)] *
					@(if (=s $arg3 "x") [result [
						(texval(vec2(texcoord0.x + offsets[@@(+ $i 1)], texcoord0.y)) +
						 texval(vec2(texcoord0.x - offsets[@@(+ $i 1)], texcoord0.y)));
					]] [result [
						(texval(vec2(texcoord0.x, texcoord0.y + offsets[@@(+ $i 1)])) +
						 texval(vec2(texcoord0.x, texcoord0.y - offsets[@@(+ $i 1)])));
					]])
				]]
			])
			gl_FragColor = val;
		}
	]
]

loop i 7 [
	blurshader (format "blurx%1" (+ $i 1)) (+ $i 1) x
	blurshader (format "blury%1" (+ $i 1)) (+ $i 1) y
	if (> $i 0) [
		altshader (format "blurx%1" (+ $i 1)) (format "blurx%1" $i)
		altshader (format "blury%1" (+ $i 1)) (format "blury%1" $i)
	]
]

////////////////////////////////////////////////
//
// full screen shaders:
//
////////////////////////////////////////////////

fsvs = [result [
	attribute vec4 vvertex;
	@(screentexcoord 0)
	uniform vec2 postfxscale;
	varying vec2 texcoord0;
	@arg2
	void main(void)
	{
		gl_Position = vvertex;   // woohoo, no mvp :)
		texcoord0 = vtexcoord0;
		@arg1
	}
]]

fsps = [result [
	uniform sampler2D tex0;
	varying vec2 texcoord0;
	@arg2
	void main(void)
	{
		vec4 color = texture2D(tex0, texcoord0);
		@arg1
	}
]]

fsvs4 = [
	fsvs [
		texcoord1 = vtexcoord0 + vec2(-1.5, -1.5)*postfxscale;
		texcoord2 = vtexcoord0 + vec2( 1.5, -1.5)*postfxscale;
		texcoord3 = vtexcoord0 + vec2(-1.5,  1.5)*postfxscale;
		texcoord4 = vtexcoord0 + vec2( 1.5,  1.5)*postfxscale;
		@arg1
	] [
		varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
	]
]

fsps4 = [
	fsps [
		vec4 s00 = texture2D(tex0, texcoord1);
		vec4 s02 = texture2D(tex0, texcoord2);
		vec4 s20 = texture2D(tex0, texcoord3);
		vec4 s22 = texture2D(tex0, texcoord4);
		@arg1
	] [
		varying vec2 texcoord1, texcoord2, texcoord3, texcoord4;
	]
]

//  Some simple ones that just do an effect on the RGB value:
lazyshader 0 "invert" (fsvs) (fsps [gl_FragColor = 1.0 - color;])
lazyshader 0 "gbr"    (fsvs) (fsps [gl_FragColor = color.yzxw;])
lazyshader 0 "bw"     (fsvs) (fsps [gl_FragColor = vec4(dot(color.xyz, vec3(0.333)));])

//  Sobel:
lazyshader 0 "sobel" (fsvs4) (fsps4 [
	vec4 t = s00 + s20 - s02 - s22;
	vec4 u = s00 + s02 - s20 - s22;
	gl_FragColor = color + t*t + u*u;
])

//  Hue, Saturation, Vibrance:
//hsv = [
//    clearpostfx
//    if (|| $arg1 (|| $arg2 $arg3)) [
//        if $arg1 [
//            _Hue = (modf $arg1 360)
//            _Hue = (? (>= $_Hue 360) (- $_Hue 360) (? (< $_Hue 0) (+ $_Hue 360) $_Hue) ) // Pre-wrap offset?
//                  echo (concatword "^f~** Hue:^t" $_Hue " degrees"); _Hue = (divf $_Hue 360)
//        ]        [echo (concatword "^f~** Hue:^t0 degrees")        ; _Hue =   0 ]
//        if $arg2 [echo (concatword "^f~** Sat:^t" $arg2 "%")       ; _Sat = (divf $arg2 100)
//        ]        [echo (concatword "^f~** Sat:^t100%")             ; _Sat = 1.0 ]
//        if $arg3 [echo (concatword "^f~** Vib:^t" $arg3 "%")       ; _Vib = (divf $arg3 100)
//        ]        [echo (concatword "^f~** Vib:^t100%")             ; _Vib = 1.0 ]
//        // addpostfx "siisffff" (name, bind, scale, inputs, params.x, params.y, params.z, params.w)
//        addpostfx "hsv" 0 0 "" $_Hue $_Sat $_Vib 0.0
//    ][
//        echo "^f~** HSV cleared"
//    ]
//]
//lazyshader 0 "hsv" [
//    attribute vec4 vvertex;
//    @(screentexcoord 0)
//    varying vec2 texcoord0;
//    void main(void)
//    {
//        gl_Position = vvertex;
//        texcoord0 = vtexcoord0;
//    }
//][
//    varying vec2 texcoord0;
//    uniform sampler2D tex0;
//    uniform vec4 params;
//    vec3 RgbToHsv(vec3 c) {
//        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
//        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
//        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
//        float d = q.x - min(q.w, q.y);
//        float e = 1.0e-10;
//        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
//    }
//    vec3 HsvToRgb(vec3 c) {
//        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
//        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
//        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
//    }
//    void main(void) {
//        vec3 TexSample0 = texture2D(tex0, texcoord0).rgb;
//        TexSample0 = RgbToHsv(TexSample0);
//
//        // Hue:
//        if (params.x != 0.0) {
//            // Shift then Wrap:
//            TexSample0.r = TexSample0.r + params.x;
//            TexSample0.r = ((TexSample0.r > 1.0) ? TexSample0.r-1.0 : (TexSample0.r < 0.0) ? TexSample0.r+1.0 : TexSample0.r);
//        }
//        // Sat:
//        TexSample0.g = TexSample0.g * params.y;
//        // Vib:
//        TexSample0.b = TexSample0.b * params.z;
//
//        TexSample0 = HsvToRgb(TexSample0);
//
//        gl_FragColor = vec4(TexSample0, 1.0);
//    }
//]

//  Rotoscope:
lazyshader 0 "rotoscope" [
	attribute vec4 vvertex;
	@(screentexcoord 0)
	uniform vec2 postfxscale;
	uniform vec4 params;
	varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
	void main(void)
	{
		gl_Position = vvertex;
		t11 = vtexcoord0;
		vec2 scale = postfxscale*params.x;
		t00 = vec2(-1.0, -1.0)*scale + vtexcoord0;
		t12 = vec2( 0.0,  1.0)*scale + vtexcoord0;
		t01 = vec2(-1.0,  0.0)*scale + vtexcoord0;
		t20 = vec2( 1.0, -1.0)*scale + vtexcoord0;
		t02 = vec2(-1.0,  1.0)*scale + vtexcoord0;
		t21 = vec2( 1.0,  0.0)*scale + vtexcoord0;
		t10 = vec2( 0.0, -1.0)*scale + vtexcoord0;
		t22 = vec2( 1.0,  1.0)*scale + vtexcoord0;
	}
] [
	uniform sampler2D tex0;
	varying vec2 t11, t00, t12, t01, t20, t02, t21, t10, t22;
	void main(void)
	{
		vec4 c00 = texture2D(tex0, t00);
		vec4 c01 = texture2D(tex0, t01);
		vec4 c02 = texture2D(tex0, t02);
		vec4 c10 = texture2D(tex0, t10);
		vec4 c11 = texture2D(tex0, t11);
		vec4 c12 = texture2D(tex0, t12);
		vec4 c20 = texture2D(tex0, t20);
		vec4 c21 = texture2D(tex0, t21);
		vec4 c22 = texture2D(tex0, t22);

		vec4 diag1 = c00 - c22;
		vec4 diag2 = c02 - c20;
		vec4 xedge = (c01 - c21)*2.0 + diag1 + diag2;
		vec4 yedge = (c10 - c12)*2.0 + diag1 - diag2;
		xedge *= xedge;
		yedge *= yedge;

		vec4 xyedge = xedge + yedge;
		float sobel = step(max(xyedge.x, max(xyedge.y, xyedge.z)), 0.1);

		float hue = dot(c11.xyz, vec3(1.0));
		c11 /= hue;
		vec3 cc = step(vec3(0.2, 0.8, 1.5), vec3(hue));
		c11 *= dot(cc, vec3(0.5, 0.5, 1.5));

		gl_FragColor = c11 * max(cc.z, sobel);
	}
]

// toast

lazyshader 0 "toast" (fsvs) (fsps [
	float bitd = 10.0;
	gl_FragColor = vec4(int(color.x*bitd)/bitd,int(color.y*bitd)/bitd,int(color.z*bitd)/bitd, (color.w*bitd)/bitd);
])

blur3shader = [
	lazyshader 0 $arg1 [
		attribute vec4 vvertex;
		@(screentexcoord 0)
		uniform vec2 postfxscale;
		varying vec2 texcoord0, texcoord1;
		void main(void)
		{
			gl_Position = vvertex;
			texcoord0 = vtexcoord0 + vec2(@(if $arg2 -0.5 0.0), @(if $arg3 -0.5 0.0))*postfxscale;
			texcoord1 = vtexcoord0 + vec2(@(if $arg2  0.5 0.0), @(if $arg3  0.5 0.0))*postfxscale;
		}
	] [
		varying vec2 texcoord0, texcoord1;
		uniform sampler2D tex0;
		void main(void)
		{
			gl_FragColor = 0.5*(texture2D(tex0, texcoord0) + texture2D(tex0, texcoord1));
		}
	]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
	lazyshader 0 $arg1 [
		attribute vec4 vvertex;
		@(screentexcoord 0)
		uniform vec2 postfxscale;
		varying vec2 texcoord0, texcoord1, texcoord2;
		void main(void)
		{
			gl_Position = vvertex;
			texcoord0 = vtexcoord0;
			texcoord1 = vtexcoord0 + vec2(@(? $arg2 -1.333 0.0), @(? $arg3 -1.333 0.0))*postfxscale;
			texcoord2 = vtexcoord0 + vec2(@(? $arg2  1.333 0.0), @(? $arg3  1.333 0.0))*postfxscale;
		}
	] [
		uniform sampler2D tex0;
		varying vec2 texcoord0, texcoord1, texcoord2;
		void main(void)
		{
			gl_FragColor = 0.4*texture2D(tex0, texcoord0) + 0.3*(texture2D(tex0, texcoord1) + texture2D(tex0, texcoord2));
		}
	]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
	clearpostfx
	if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
	if (>= $numargs 2) [
		if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
		if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
	]
]

shader 0 "screenrect" [
	attribute vec4 vvertex, vcolor;
	@(screentexcoord 0)
	varying vec2 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec2 texcoord0;
	varying vec4 color;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0);
	}
]

//  Bloom-ish
lazyshader 0 "bloom_scale" (fsvs4) (fsps4 [
	gl_FragColor = 0.2 * (s02 + s00 + s22 + s20 + color);
])

lazyshader 0 "bloom_init" (fsvs) (fsps [
	float t = max(color.r, max(color.g, color.b));
	gl_FragColor = t*t*color;
])

bloomshader = [
  defershader 0 $arg1 [
	forceshader "bloom_scale"
	forceshader "bloom_init"
	shader 0 @arg1 [
		attribute vec4 vvertex;
		@(screentexcoord 0)
		varying vec2 texcoord0;
		void main(void)
		{
			gl_Position = vvertex;
			texcoord0 = vtexcoord0;
		}
	] [
		uniform vec4 params;
		varying vec2 texcoord0;
		uniform sampler2D tex0 @@(loopconcat i $arg2 [result [, tex@(+ $i 1)]]);
		void main(void)
		{
			vec4 sample = texture2D(tex0, texcoord0);
			@@(loopconcat i $arg2 [result [
				@(? $i "bloom +=" "vec4 bloom =") texture2D(tex@(+ $i 1), texcoord0);
			]])
			gl_FragColor = bloom*params.x + sample;
		}
	]
  ]
]

bloomshader bloom1 1
bloomshader bloom2 2
bloomshader bloom3 3
bloomshader bloom4 4
bloomshader bloom5 5
bloomshader bloom6 6

setupbloom = [
	addpostfx bloom_init 1 1 "+0"
	loop i (- $arg1 1) [
		addpostfx bloom_scale (+ $i 2) (+ $i 2) (concatword "+" (+ $i 1))
	]
	addpostfx (concatword bloom $arg1) 0 0 (loopconcat i (+ $arg1 1) [result $i]) $arg2
]

bloom = [
	clearpostfx
	if (>= $numargs 1) [setupbloom 6 $arg1]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders:
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords
// and blends the edge color
// and modulates the texture
explosionshader = [
	shader 0 $arg1 [
		//:fog
		attribute vec4 vvertex, vcolor;
		attribute vec2 vtexcoord0;
		uniform mat4 explosionmatrix;
		uniform vec3 center;
		uniform float millis;
		uniform vec3 texgenS, texgenT;
		varying vec4 color;
		varying vec2 texcoord0, texcoord1, texcoord2;
		@(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; varying vec4 texcoord3; ]])
		void main(void)
		{
			vec4 wobble = vec4(vvertex.xyz*(1.0 + 0.5*abs(fract(dot(vvertex.xyz, center) + millis*2.0) - 0.5)), vvertex.w);
			@(if (>= (strstr $arg1 "soft") 0) [result [
				gl_Position = explosionmatrix * wobble;

				texcoord3 = vec4(0.5*(gl_Position.xy + gl_Position.w), gl_Position.w, depthfxparams.y + gl_Position.w*depthfxparams.x);
			]] [result [
				gl_Position = explosionmatrix * wobble;
			]])

			color = vcolor;

			texcoord0 = vtexcoord0;
			vec2 texgen = vec2(dot(texgenS, vvertex.xyz), dot(texgenT, vvertex.xyz));
			texcoord1 = texgen;
			texcoord2 = 0.5*texgen - millis*0.5;
		}
	] [
		@(if (>= (strstr $arg1 "soft") 0) [result [
			uniform sampler2D tex2;
		]])
		uniform sampler2D tex0, tex1;
		uniform vec2 blendparams;
		varying vec4 color;
		varying vec2 texcoord0, texcoord1, texcoord2;
		@(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; varying vec4 texcoord3; ]])
		@(if (>= (strstr $arg1 "soft8") 0) [result [uniform vec4 depthfxselect;]])
		void main(void)
		{
			vec2 dtc = texcoord0 + texture2D(tex0, texcoord2).xy*0.1; // use color texture as noise to distort texcoords
			vec4 diffuse = texture2D(tex0, dtc);
			float blend = max(pow(clamp(1.0 - dot(texcoord1, texcoord1), 0.0, 1.0), blendparams.x), blendparams.y);
			@(if (>= (strstr $arg1 "glare") 0) [result [
				float k = blend*blend;
				diffuse.rgb *= k*8.0;
				diffuse.a *= k;
				diffuse.b += k*k;
			]] [result [
				diffuse *= blend*4.0; // dup alpha into RGB channels + intensify and over saturate
				diffuse.b += 0.5 - blend*0.5; // blue tint
			]])

			@(if (>= (strstr $arg1 "soft") 0) [result [
				gl_FragColor.rgb = diffuse.rgb * color.rgb;

				#define depthvals texture2DProj(tex2, texcoord3.xyz)
				@(if (>= (strstr $arg1 "soft8") 0) [result [
					float depth = dot(depthvals, depthfxselect);
				]] [result [
					float depth = depthvals.x*depthfxparams.z;
				]])
				gl_FragColor.a = diffuse.a * max(clamp(depth - texcoord3.w, 0.0, 1.0) * color.a, depthfxparams.w);
			]] [result [
				gl_FragColor = diffuse * color;
			]])
		}
	]
]

looplist i ["" "glare" "soft" "soft8"] [
	explosionshader [explosion@i]
]

shader 0 "particlenotexture" [
	//:fog
	attribute vec4 vvertex, vcolor;
	uniform mat4 camprojmatrix;
	uniform vec4 colorscale;
	varying vec4 color;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor * colorscale;
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]

particleshader = [
	shader 0 $arg1 [
		//:fog
		attribute vec4 vvertex, vcolor;
		attribute vec2 vtexcoord0;
		uniform mat4 camprojmatrix;
		uniform vec4 colorscale;
		varying vec2 texcoord0;
		varying vec4 color;
		@(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; varying vec3 texcoord1, surface; ]])
		void main(void)
		{
			gl_Position = camprojmatrix * vvertex;
			texcoord0 = vtexcoord0;
			color = vcolor * colorscale;

			@(if (>= (strstr $arg1 "soft") 0) [result [
				texcoord1 = vec3(0.5*(gl_Position.xy + gl_Position.w), gl_Position.w);

				vec2 offset = vtexcoord0*2.82842712474619 - 1.4142135623731;
				surface = vec3(offset, depthfxparams.y + gl_Position.w*depthfxparams.x);
			]])
		}
	] [
		@(if (>= (strstr $arg1 "soft") 0) [result [
			uniform sampler2D tex2;
		]])
		uniform sampler2D tex0;
		varying vec2 texcoord0;
		varying vec4 color;
		@(if (>= (strstr $arg1 "soft") 0) [result [uniform vec4 depthfxparams; varying vec3 texcoord1, surface;]])
		@(if (>= (strstr $arg1 "soft8") 0) [result [uniform vec4 depthfxselect;]])
		void main(void)
		{
			vec4 diffuse = texture2D(tex0, texcoord0);

			@(if (>= (strstr $arg1 "soft") 0) [result [
				#define depthvals texture2DProj(tex2, texcoord1)
				@(if (>= (strstr $arg1 "soft8") 0) [result [
					float depth = dot(depthvals, depthfxselect);
				]] [result [
					float depth = depthvals.x*depthfxparams.z;
				]])
				diffuse.a *= clamp(depth - dot(surface.xy, surface.xy) - surface.z, 0.0, 1.0);
			]])

			gl_FragColor = diffuse * color;
		}
	]
]

looplist i ["" "soft" "soft8"] [
	particleshader [particle@i]
]

shader 0 "blendbrush" [
	attribute vec4 vvertex, vcolor;
	uniform mat4 camprojmatrix;
	uniform vec4 texgenS, texgenT;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		texcoord0 = vec2(dot(texgenS, vvertex), dot(texgenT, vvertex));
	}
] [
	varying vec4 color;
	varying vec2 texcoord0;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor = texture2D(tex0, texcoord0).r * color;
	}
]

lazyshader 0 "prefab" [
	attribute vec4 vvertex, vcolor;
	attribute vec3 vnormal;
	uniform mat4 prefabmatrix;
	uniform mat3 prefabworld;
	varying vec4 color;

	void main(void)
	{
		gl_Position = prefabmatrix * vvertex;
		color = vcolor;
		color.rgb *= dot(prefabworld * vnormal, vec3(0.0, -0.447213595, 0.894427191));
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor = color;
	}
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

watershader = [
	specular = $arg2
	rgbfog = $arg3
	distort = $arg4
	combine = $arg5
	lazyshader 0 $arg1 [
		attribute vec4 vvertex;
		attribute vec3 vcolor;
		uniform mat4 camprojmatrix;
		uniform vec3 camera;
		uniform mat4 watermatrix;
		uniform float waterheight;
		uniform float millis;
		@(if $specular [result [uniform vec3 lightpos; varying vec3 lightdir;]])
		varying vec3 camdir, color;
		varying vec4 texcoord0;
		varying vec2 texcoord1, texcoord2;
		void main(void)
		{
			gl_Position = camprojmatrix * vvertex;
			color = vcolor;
			texcoord0 = watermatrix * vvertex;
			@(if (>= (strstr $arg1 "underwater") 0) [result [
				texcoord0.z = waterheight - vvertex.z;
			]] [result [
				texcoord0.z = vvertex.z - waterheight;
			]])
			vec2 tc = vvertex.xy * 0.02;
			texcoord1 = tc + millis*0.05;
			texcoord2 = tc - millis*0.03;
			camdir = camera - vvertex.xyz;
			@(if $specular [result [
				lightdir = lightpos - vvertex.xyz;
			]])
		}
	] [
		@(if $rgbfog [result [
			//:fog
		]] [result [
			//:fogrgba vec4(vec3(0.0), 1.0)
		]])
		uniform vec2 depth;
		@(if $specular [result [uniform vec3 lightcolor; uniform float lightradius; varying vec3 lightdir;]])
		varying vec3 camdir, color;
		varying vec4 texcoord0;
		varying vec2 texcoord1, texcoord2;
		@(if (>= (strstr $arg1 "env") 0) [result [
			uniform samplerCube tex0;
		]] [result [
			uniform sampler2D tex0;
		]])
		uniform sampler2D tex1, tex2, tex3;
		void main(void)
		{
			vec3 camvec = normalize(camdir);
			@(if $specular [result [
				vec3 lightvec = normalize(lightdir);
				vec3 halfangle = normalize(camvec + lightvec);
			]])

			vec2 dudv = texture2D(tex2, texcoord1).xy*2.0 - 1.0;

			@distort

			@(if $specular [result [
				float spec = pow(clamp(dot(halfangle, bump), 0.0, 1.0), 96.0);
				vec3 light = lightcolor * (1.0 - clamp(length(lightdir)/lightradius, 0.0, 1.0));
			]])

			@combine
		}
	]
]

watershader "waterglare" 1 1 [
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	gl_FragColor = vec4(light*spec*spec*32.0, 0.0);
]
lazyshader 0 "waterglarefast" [
	//:fog
	attribute vec4 vvertex;
	uniform mat4 camprojmatrix;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
	}
] [
	void main(void)
	{
		gl_FragColor = vec4(0.0);
	}
]
fastshader waterglare waterglarefast 2
altshader waterglare waterglarefast

lazyshader 0 "underwater" [
	attribute vec4 vvertex;
	attribute vec3 vcolor;
	uniform mat4 camprojmatrix;
	varying vec3 color;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
	}
] [
	//:fogrgba vec4(vec3(0.0), 1.0)
	uniform vec2 depth;
	varying vec3 color;
	void main(void)
	{
		gl_FragColor.rgb = 0.8*depth.x*color;
		gl_FragColor.a = 0.5*depth.y;
	}
]

watershader "underwaterrefract" 0 1 [
	dudv = texture2D(tex2, texcoord2 + 0.025*dudv).xy*2.0 - 1.0;

	gl_FragColor = texture2D(tex3, texcoord0.xy/texcoord0.w + 0.007*dudv);
] []
watershader "underwaterrefractfast" 0 1 [
	gl_FragColor = texture2DProj(tex3, texcoord0 + vec4(0.3*dudv, 0.0, 0.0));
] []
fastshader underwaterrefract underwaterrefractfast 2
altshader underwaterrefract underwaterrefractfast

watershader "underwaterfade" 0 1 [
	dudv = texture2D(tex2, texcoord2 + 0.025*dudv).xy*2.0 - 1.0;

	vec2 projtc = texcoord0.xy/texcoord0.w;
	float fade = texcoord0.z + 4.0*texture2D(tex3, projtc).a;
	gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);
	gl_FragColor.rgb = texture2D(tex3, projtc + 0.007*dudv).rgb;
] []
watershader "underwaterfadefast" 0 1 [
	gl_FragColor.rgb = texture2DProj(tex3, texcoord0 + vec4(0.3*dudv, 0.0, 0.0)).rgb;
	gl_FragColor.a = texcoord0.z + 4.0*texture2DProj(tex3, texcoord0).a;
] []
fastshader underwaterfade underwaterfadefast 2
altshader underwaterfade underwaterfadefast

watershader "water" 1 0 [
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor.rgb = color*depth.x*mix(0.6, 1.0, invfresnel*0.5+0.5) + spec*light;
	gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterfast" 0 0 [
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor.rgb = color*depth.x*mix(0.6, 1.0, invfresnel*0.5+0.5);
	gl_FragColor.a = invfresnel*depth.y;
]
fastshader water waterfast 1
altshader water waterfast

watershader "waterreflect" 1 0 [
	vec3 reflect = texture2DProj(tex0, texcoord0 + vec4(0.3*dudv, 0.0, 0.0)).rgb;
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5) + spec*light;
	gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterreflectfast" 0 0 [
	vec3 reflect = texture2DProj(tex0, texcoord0 + vec4(0.3*dudv, 0.0, 0.0)).rgb;
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5);
	gl_FragColor.a = invfresnel*depth.y;
]
fastshader waterreflect waterreflectfast 2
altshader waterreflect waterreflectfast

watershader "waterrefract" 1 1 [
	vec2 dtc = texcoord2 + 0.025*dudv;
	vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
	dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

	vec2 rtc = texcoord0.xy/texcoord0.w + 0.007*dudv;
	vec3 reflect = texture2D(tex0, rtc).rgb;
	vec3 refract = texture2D(tex3, rtc).rgb;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5) + spec*light, 0.0);
]
watershader "waterrefractfast" 0 1 [
	vec4 rtc = texcoord0 + vec4(0.3*dudv, 0.0, 0.0);
	vec3 reflect = texture2DProj(tex0, rtc).rgb;
	vec3 refract = texture2DProj(tex3, rtc).rgb;
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5), 0.0);
]
fastshader waterrefract waterrefractfast 2
altshader waterrefract waterrefractfast

watershader "waterfade" 1 1 [
	vec2 dtc = texcoord2 + 0.025*dudv;
	vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
	dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

	vec2 projtc = texcoord0.xy/texcoord0.w;
	vec2 rtc = projtc + 0.007*dudv;
	vec3 reflect = texture2D(tex0, rtc).rgb;
	vec3 refract = texture2D(tex3, rtc).rgb;
	float fade = texcoord0.z + 4.0*texture2D(tex3, projtc).a;
	gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5) + spec*light;
]
watershader "waterfadefast" 0 1 [
	vec4 rtc = texcoord0 + vec4(0.3*dudv, 0.0, 0.0);
	vec3 reflect = texture2DProj(tex0, rtc).rgb;
	vec3 refract = texture2DProj(tex3, rtc).rgb;
	gl_FragColor.a = texcoord0.z + 4.0*texture2DProj(tex3, texcoord0).a;
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
] [
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5);
]
fastshader waterfade waterfadefast 2
altshader waterfade waterrefract

watershader "waterenv" 1 0 [
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
	gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5) + spec*light;
	gl_FragColor.a = invfresnel*depth.y;
]
watershader "waterenvfast" 0 0 [
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
	gl_FragColor.rgb = mix(reflect, color*depth.x, invfresnel*0.5+0.5);
	gl_FragColor.a = invfresnel*depth.y;
]
fastshader waterenv waterenvfast 2
altshader waterenv waterenvfast

watershader "waterenvrefract" 1 1 [
	vec2 dtc = texcoord2 + 0.025*dudv;
	vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
	dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

	vec3 refract = texture2D(tex3, texcoord0.xy/texcoord0.w + 0.007*dudv).rgb;
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
	gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5) + spec*light, 0.0);
]
watershader "waterenvrefractfast" 0 1 [
	vec3 refract = texture2DProj(tex3, texcoord0 + vec4(0.3*dudv, 0.0, 0.0)).rgb;
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
	gl_FragColor = vec4(mix(reflect, refract, invfresnel*0.5+0.5), 0.0);
]
fastshader waterenvrefract waterenvrefractfast 2
altshader waterenvrefract waterenvrefractfast

watershader "waterenvfade" 1 1 [
	vec2 dtc = texcoord2 + 0.025*dudv;
	vec3 bump = texture2D(tex1, dtc).rgb*2.0 - 1.0;
	dudv = texture2D(tex2, dtc).xy*2.0 - 1.0;

	vec2 projtc = texcoord0.xy/texcoord0.w;
	vec3 refract = texture2D(tex3, projtc + 0.007*dudv).rgb;
	float fade = texcoord0.z + 4.0*texture2D(tex3, projtc).a;
	gl_FragColor.a = fade * clamp(gl_FragCoord.z, 0.0, 1.0);

	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
	gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5) + spec*light;
]
watershader "waterenvfadefast" 0 1 [
	vec3 refract = texture2DProj(tex3, texcoord0 + vec4(0.3*dudv, 0.0, 0.0)).rgb;
	gl_FragColor.a = texcoord0.z + 4.0*texture2DProj(tex3, texcoord0).a;
	vec3 bump = texture2D(tex1, texcoord2 + 0.025*dudv).rgb*2.0 - 1.0;
	float invfresnel = clamp(dot(camvec, bump), 0.0, 1.0);
	vec3 reflect = textureCube(tex0, camvec - 2.0*invfresnel*bump).rgb;
] [
	gl_FragColor.rgb = mix(reflect, refract, invfresnel*0.5+0.5);
]
fastshader waterenvfade waterenvfadefast 2
altshader waterenvfade waterenvrefract

causticshader = [
	lazyshader 0 $arg1 [
		attribute vec4 vvertex;
		uniform mat4 camprojmatrix;
		uniform vec3 texgenS, texgenT;
		varying vec2 texcoord0;
		void main(void)
		{
			gl_Position = camprojmatrix * vvertex;
			texcoord0 = vec2(dot(texgenS, vvertex.xyz), dot(texgenT, vvertex.xyz));
		}
	] [
		//:fog vec3(1.0)
		uniform vec4 frameblend;
		varying vec2 texcoord0;
		uniform sampler2D tex0, tex1;
		void main(void)
		{
			@arg2
		}
	]
]
causticshader caustic [
	gl_FragColor = vec4(vec3(frameblend.x*texture2D(tex0, texcoord0).r + frameblend.y*texture2D(tex1, texcoord0).r + frameblend.w), 1.0);
]

lazyshader 0 "lava" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec3 vnormal;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	uniform vec4 lavatexgen;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		vec2 tc = mix(vvertex.xz, vvertex.yy, abs(vnormal.xz));
		texcoord0 = (tc + lavatexgen.zw) * lavatexgen.xy;
	}
] [
	uniform sampler2D tex0;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0) * 2.0;
	}
]

lazyshader 0 "lavaglare" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec3 vnormal;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	uniform vec4 lavatexgen;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vec4(vcolor.rgb*2.0 - 1.0, vcolor.a);
		vec2 tc = mix(vvertex.xz, vvertex.yy, abs(vnormal.xz));
		texcoord0 = (tc + lavatexgen.zw) * lavatexgen.xy;
	}
] [
	uniform sampler2D tex0;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		vec4 glow = texture2D(tex0, texcoord0) * color;
		float k = max(glow.r, max(glow.g, glow.b));
		gl_FragColor = glow*k*k*32.0;
	}
]

lazyshader 0 "waterfall" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec3 vnormal;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	uniform vec4 waterfalltexgen;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		vec2 tc = mix(vvertex.xz, vvertex.yy, abs(vnormal.xz));
		texcoord0 = (tc + waterfalltexgen.zw) * waterfalltexgen.xy;
	}
] [
	uniform sampler2D tex0;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0);
	}
]

lazyshader 0 "waterfallrefract" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec3 vnormal;
	uniform mat4 camprojmatrix;
	uniform mat4 watermatrix;
	varying vec4 color;
	uniform vec4 waterfalltexgen;
	varying vec2 texcoord0;
	varying vec4 texcoord1;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		vec2 tc = mix(vvertex.xz, vvertex.yy, abs(vnormal.xz));
		texcoord0 = (tc + waterfalltexgen.zw) * waterfalltexgen.xy;
		texcoord1 = watermatrix * vvertex;
	}
] [
	uniform vec2 dudvoffset;
	uniform sampler2D tex0, tex2, tex4;
	varying vec4 color;
	varying vec2 texcoord0;
	varying vec4 texcoord1;
	void main(void)
	{
		vec4 diffuse = texture2D(tex0, texcoord0);
		vec2 dudv = texture2D(tex2, texcoord0 + 0.2*diffuse.xy + dudvoffset).xy;
		vec4 refract = texture2DProj(tex4, texcoord1 + vec4(4.0*dudv, 0.0, 0.0));
		gl_FragColor = mix(refract, color, diffuse);
	}
]

lazyshader 0 "waterfallenvrefract" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec3 vnormal;
	uniform mat4 camprojmatrix;
	uniform mat4 watermatrix;
	uniform vec3 camera;
	varying vec4 color;
	uniform vec4 waterfalltexgen;
	varying vec2 texcoord0;
	varying vec4 texcoord1;
	varying vec3 camdir;
	varying mat3 world;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		camdir = camera - vvertex.xyz;
		vec3 absnorm = abs(vnormal);
		world = mat3(absnorm.yzx, -absnorm.zxy, vnormal);
		vec2 tc = mix(vvertex.xz, vvertex.yy, absnorm.xz);
		texcoord0 = (tc + waterfalltexgen.zw) * waterfalltexgen.xy;
		texcoord1 = watermatrix * vvertex;
	}
] [
	uniform vec2 dudvoffset;
	uniform sampler2D tex0, tex1, tex2, tex4;
	uniform samplerCube tex3;
	varying vec4 color;
	varying vec2 texcoord0;
	varying vec4 texcoord1;
	varying vec3 camdir;
	varying mat3 world;
	void main(void)
	{
		vec4 diffuse = texture2D(tex0, texcoord0);
		vec2 dudv = texture2D(tex2, texcoord0 + 0.2*diffuse.xy + dudvoffset).xy;
		vec3 normal = world * (texture2D(tex1, texcoord0 + 0.1*dudv).rgb*2.0 - 1.0);
		vec4 refract = texture2DProj(tex4, texcoord1 + vec4(4.0*dudv, 0.0, 0.0));
		vec3 camvec = normalize(camdir);
		float invfresnel = dot(normal, camvec);
		vec4 reflect = textureCube(tex3, 2.0*invfresnel*normal - camvec);
		gl_FragColor = mix(mix(reflect, refract, 1.0 - 0.4*step(0.0, invfresnel)), color, diffuse);
	}
]
altshader waterfallenvrefract waterfallrefract

lazyshader 0 "waterfallenv" [
	//:fog
	attribute vec4 vvertex;
	attribute vec3 vcolor, vnormal;
	uniform mat4 camprojmatrix;
	uniform vec3 camera;
	uniform vec4 waterfalltexgen;
	varying vec2 texcoord0;
	varying vec3 color, camdir;
	varying mat3 world;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		camdir = camera - vvertex.xyz;
		vec3 absnorm = abs(vnormal);
		world = mat3(absnorm.yzx, -absnorm.zxy, vnormal);
		vec2 tc = mix(vvertex.xz, vvertex.yy, absnorm.xz);
		texcoord0 = (tc + waterfalltexgen.zw) * waterfalltexgen.xy;
	}
] [
	uniform vec2 dudvoffset;
	uniform sampler2D tex0, tex1, tex2;
	uniform samplerCube tex3;
	varying vec2 texcoord0;
	varying vec3 color, camdir;
	varying mat3 world;
	void main(void)
	{
		vec4 diffuse = texture2D(tex0, texcoord0);
		vec2 dudv = texture2D(tex2, texcoord0 + 0.2*diffuse.xy + dudvoffset).xy;
		vec3 normal = world * (texture2D(tex1, texcoord0 + 0.1*dudv).rgb*2.0 - 1.0);
		vec3 camvec = normalize(camdir);
		vec4 reflect = textureCube(tex3, 2.0*dot(normal, camvec)*normal - camvec);
		gl_FragColor.rgb = mix(reflect.rgb, color, diffuse.rgb);
		gl_FragColor.a = 0.25 + 0.75*diffuse.r;
	}
]

lazyshader 0 "glass" [
	attribute vec4 vvertex;
	attribute vec3 vcolor, vnormal;
	uniform mat4 camprojmatrix;
	uniform vec3 camera;
	varying vec3 color, rvec, camdir, normal;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		normal = vnormal;
		camdir = camera - vvertex.xyz;
		rvec = 2.0*dot(camdir, vnormal) * vnormal - camdir;
	}
] [
	//:fogrgba vec4(vec3(0.0), 1.0)
	uniform samplerCube tex0;
	varying vec3 color, rvec, camdir, normal;
	void main(void)
	{
		vec3 camvec = normalize(camdir);
		vec3 reflect = textureCube(tex0, rvec).rgb;

		float invfresnel = max(dot(camvec, normal), 0.70);
		gl_FragColor.rgb = mix(reflect, color*0.05, invfresnel);
		gl_FragColor.a = invfresnel * 0.95;
	}
]
lazyshader 0 "glassfast" [
	attribute vec4 vvertex;
	attribute vec3 vcolor, vnormal;
	uniform mat4 camprojmatrix;
	uniform vec3 camera;
	varying vec3 color, rvec;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		vec3 camdir = camera - vvertex.xyz;
		rvec = 2.0*dot(camdir, vnormal) * vnormal - camdir;
	}
] [
	//:fogrgba vec4(vec3(0.0), 1.0)
	uniform samplerCube tex0;
	varying vec3 color, rvec;
	void main(void)
	{
		vec3 reflect = textureCube(tex0, rvec).rgb;
		const float invfresnel = 0.75;
		gl_FragColor.rgb = mix(reflect, color*0.05, invfresnel);
		gl_FragColor.a = invfresnel * 0.95;
	}
]
fastshader glass glassfast 2
altshader glass glassfast

lazyshader 0 "grass" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0, vtexcoord1;
	attribute vec4 vtangent;
	uniform mat4 camprojmatrix;
	uniform vec3 camera;
	uniform vec3 grassmargin;
	varying vec4 color;
	varying vec2 texcoord0, texcoord1;
	varying vec2 bounds;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		texcoord0 = vtexcoord0;
		texcoord1 = vtexcoord1 * @lmcoordscale;
		vec2 camdir = (camera.xy - vvertex.xy) * grassmargin.y;
		bounds = vec2(dot(camdir, vtangent.xy), dot(camdir, vtangent.zw)) + grassmargin.z;
	}
] [
	//:fogrgba vec4(0.0)
	varying vec4 color;
	varying vec2 texcoord0, texcoord1;
	varying vec2 bounds;
	uniform sampler2D tex0, tex1;
	void main(void)
	{
		vec4 diffuse = texture2D(tex0, texcoord0);
		diffuse.rgb *= 2.0;
		vec4 lm = texture2D(tex1, texcoord1) * color;
		lm.rgb *= lm.a;
		float margin = clamp(min(bounds.x, bounds.y), 0.0, 1.0);
		gl_FragColor = diffuse * lm * margin;
	}
]

shader 0 "overbrightdecal" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		texcoord0 = vtexcoord0;
	}
] [
	//:fog vec3(0.5)
	varying vec4 color;
	varying vec2 texcoord0;
	uniform sampler2D tex0;
	void main(void)
	{
		vec4 diffuse = texture2D(tex0, texcoord0);
		gl_FragColor = mix(color, diffuse, color.a);
	}
]

shader 0 "saturatedecal" [
	//:fog
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 camprojmatrix;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = camprojmatrix * vvertex;
		color = vcolor;
		texcoord0 = vtexcoord0;
	}
] [
	varying vec4 color;
	varying vec2 texcoord0;
	uniform sampler2D tex0;
	void main(void)
	{
		vec4 diffuse = texture2D(tex0, texcoord0);
		diffuse.rgb *= 2.0;
		gl_FragColor = diffuse * color;
	}
]

shader 0 "skybox" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 skymatrix;
	varying vec2 texcoord0;
	varying vec4 color;
	void main(void)
	{
		gl_Position = skymatrix * vvertex;
		texcoord0 = vtexcoord0;
		color = vcolor;
	}
] [
	varying vec2 texcoord0;
	varying vec4 color;
	uniform sampler2D tex0;
	void main(void)
	{
		gl_FragColor = color * texture2D(tex0, texcoord0);
	}
]

shader 0 "skyboxglare" [
	attribute vec4 vvertex, vcolor;
	attribute vec2 vtexcoord0;
	uniform mat4 skymatrix;
	varying vec4 color;
	varying vec2 texcoord0;
	void main(void)
	{
		gl_Position = skymatrix * vvertex;
		color = vcolor;
		texcoord0 = vtexcoord0;
	}
] [
	varying vec4 color;
	varying vec2 texcoord0;
	uniform sampler2D tex0;
	void main(void)
	{
		vec4 glare = texture2D(tex0, texcoord0) * color;
		gl_FragColor.rgb = vec3(dot(glare.rgb, vec3(10.56, 10.88, 10.56)) - 30.4);
		gl_FragColor.a = glare.a;
	}
]

shader 0 "skyfog" [
	attribute vec4 vvertex, vcolor;
	uniform mat4 skymatrix;
	varying vec4 color;
	void main(void)
	{
		gl_Position = skymatrix * vvertex;
		color = vcolor;
	}
] [
	varying vec4 color;
	void main(void)
	{
		gl_FragColor =
			//:variantoverride vec4(color.rgb, color.a * color.a)
			color
			;
	}
]

loop i 2 [
  lazyshader 0 (? $i "atmosphereglare" "atmosphere") [
	attribute vec4 vvertex;
	uniform mat4 skymatrix;
	varying vec3 camvec;
	void main(void)
	{
		gl_Position = skymatrix * vvertex;

		camvec = vvertex.xyz;
	}
  ] [
	uniform vec4 sunlight;
	uniform vec3 sundir;
	uniform vec3 sunweight;
	uniform vec3 sundiskcolor;
	uniform vec2 sundiskparams;
	uniform vec4 opticaldepthparams;
	uniform vec3 mieparams;
	uniform vec3 betarayleigh, betamie, betaozone;
	varying vec3 camvec;

	void main(void)
	{
		vec3 camdir = normalize(camvec);
		float costheta = dot(camdir, sundir);

		// sun disk
		float edgeoffset = max(1.0 - (1.0 - max(costheta, 0.0)*costheta)*sundiskparams.x, 0.0);
		// limb darken with distance to edge
		float limbdarken = sqrt(edgeoffset);
		// lighten edges for corona, but limit it to not interfere with limb darkening
		float corona = min(edgeoffset * sundiskparams.y, 1.0);
		corona = max(0.75 / (1.5 - corona * corona) - 0.5, 0.0);
		// apply limb darkening and corona to clamped sunlight color
		vec3 sundisk = sundiskcolor * limbdarken * corona;

		// optical depth along view ray
		float offset = camdir.z*opticaldepthparams.w;
		vec3 depth = sqrt(offset*offset + opticaldepthparams.xyz) - offset;
		vec3 rayleighweight = betarayleigh * depth.x;
		vec3 mieweight = betamie * depth.y;
		vec3 ozoneweight = betaozone * (depth.z - depth.x);

		// extinction of light along view ray
		vec3 viewweight = sunweight - (rayleighweight + mieweight + ozoneweight);
		vec3 extinction = (exp2(viewweight) - 1.0) / viewweight;

		@(? $i [
			// only glare sundisk, excluding other scattering
			// squared (by skipping gamma encode) to limit it
			gl_FragColor = vec4(sundisk * extinction, sunlight.a);
		] [
			// calculate in-scattering
			float rphase = (1.5 + 0.5*costheta*costheta) * (3.0 / (16.0 * 3.14159265));
			float mphase = inversesqrt(mieparams.x + mieparams.y*min(costheta, mieparams.z));
			vec3 scatter = rayleighweight * rphase + mieweight * (mphase * mphase * mphase);

			// combine scattering and extinction with sundisk
			vec3 inscatter = (sunlight.rgb * scatter + sundisk) * extinction;

			// gamma encode
			gl_FragColor = vec4(sqrt(inscatter), sunlight.a);
		])
	}
  ]
]
